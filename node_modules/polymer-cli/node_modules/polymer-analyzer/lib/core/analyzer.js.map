{"version":3,"sources":["../src/core/analyzer.ts"],"names":[],"mappings":"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","file":"analyzer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/// <reference path=\"../../custom_typings/main.d.ts\" />\n\nimport * as path from 'path';\n\nimport {ParsedDocument} from '..';\nimport {Analysis, Document, Warning} from '../model/model';\nimport {PackageRelativeUrl, ResolvedUrl} from '../model/url';\nimport {Parser} from '../parser/parser';\nimport {Scanner} from '../scanning/scanner';\nimport {UrlLoader} from '../url-loader/url-loader';\nimport {UrlResolver} from '../url-loader/url-resolver';\n\nimport {AnalysisContext} from './analysis-context';\nimport {MinimalCancelToken, neverCancels} from './cancel-token';\n\nexport interface Options {\n  urlLoader: UrlLoader;\n  urlResolver?: UrlResolver;\n  parsers?: Map<string, Parser<ParsedDocument>>;\n  scanners?: ScannerTable;\n\n  /**\n   * Map from url of an HTML Document to another HTML document it lazily depends\n   * on.\n   */\n  lazyEdges?: LazyEdgeMap;\n\n  /**\n   * Algorithm to use for resolving module specifiers in import\n   * and export statements when rewriting them to be web-compatible.\n   * A value of 'node' uses Node.js resolution to find modules.\n   */\n  moduleResolution?: 'node';\n\n  // For internal use\n  __contextPromise?: Promise<AnalysisContext>;\n}\n\nexport interface AnalyzeOptions {\n  /**\n   * Used to indicate that the caller no longer cares about the result\n   * of the analysis, to save on effort.\n   */\n  readonly cancelToken?: MinimalCancelToken;\n}\n\n/**\n * These are the options available to the `_fork` method.  Currently, only the\n * `urlLoader` override is implemented.\n */\nexport interface ForkOptions { urlLoader?: UrlLoader; }\n\nexport class NoKnownParserError extends Error {}\n\nexport type ScannerTable =\n    Map<string, Scanner<ParsedDocument, {}|null|undefined, {}>[]>;\nexport type LazyEdgeMap = Map<ResolvedUrl, PackageRelativeUrl[]>;\n\n/**\n * A static analyzer for web projects.\n *\n * An Analyzer can load and parse documents of various types, and extract\n * arbitrary information from the documents, and transitively load\n * dependencies. An Analyzer instance is configured with parsers, and scanners\n * which do the actual work of understanding different file types.\n */\nexport class Analyzer {\n  private _analysisComplete: Promise<AnalysisContext>;\n  readonly urlResolver: UrlResolver;\n  private readonly _urlLoader: UrlLoader;\n\n  constructor(options: Options) {\n    if (options.__contextPromise) {\n      this._urlLoader = options.urlLoader;\n      this.urlResolver = options.urlResolver!;\n      this._analysisComplete = options.__contextPromise;\n    } else {\n      const context = new AnalysisContext(options);\n      this.urlResolver = context.resolver;\n      this._urlLoader = context.loader;\n      this._analysisComplete = Promise.resolve(context);\n    }\n  }\n\n  /**\n   * Loads, parses and analyzes the root document of a dependency graph and its\n   * transitive dependencies.\n   */\n  async analyze(urls: string[], options: AnalyzeOptions = {}):\n      Promise<Analysis> {\n    const previousAnalysisComplete = this._analysisComplete;\n    const uiUrls = this.brandUserInputUrls(urls);\n    let filesWithParsers: PackageRelativeUrl[];\n    this._analysisComplete = (async () => {\n      const previousContext = await previousAnalysisComplete;\n      filesWithParsers =\n          this._filterFilesByParsableExtension(uiUrls, previousContext);\n      return await previousContext.analyze(\n          filesWithParsers, options.cancelToken || neverCancels);\n    })();\n    const context = await this._analysisComplete;\n    const resolvedUrls = context.resolveUserInputUrls(filesWithParsers!);\n    return this._constructAnalysis(context, resolvedUrls);\n  }\n\n  async analyzePackage(options: AnalyzeOptions = {}): Promise<Analysis> {\n    const previousAnalysisComplete = this._analysisComplete;\n    let analysis: Analysis;\n    this._analysisComplete = (async () => {\n      const previousContext = await previousAnalysisComplete;\n      if (!previousContext.loader.readDirectory) {\n        throw new Error(\n            `This analyzer doesn't support analyzerPackage, ` +\n            `the urlLoader can't list the files in a directory.`);\n      }\n      const allFiles =\n          await previousContext.loader.readDirectory('' as ResolvedUrl, true);\n      // TODO(rictic): parameterize this, perhaps with polymer.json.\n      const filesInPackage =\n          allFiles.filter((file) => !Analysis.isExternal(file));\n      const filesWithParsers =\n          this._filterFilesByParsableExtension(filesInPackage, previousContext);\n\n      const newContext = await previousContext.analyze(\n          filesWithParsers, options.cancelToken || neverCancels);\n      const resolvedFilesWithParsers =\n          newContext.resolveUserInputUrls(filesWithParsers);\n      analysis = this._constructAnalysis(newContext, resolvedFilesWithParsers);\n      return newContext;\n    })();\n    await this._analysisComplete;\n    return analysis!;\n  }\n\n  private _filterFilesByParsableExtension(\n      filenames: PackageRelativeUrl[], context: AnalysisContext) {\n    const extensions = new Set(context.parsers.keys());\n    return filenames.filter(\n        (fn) => extensions.has(path.extname(fn).substring(1)));\n  }\n\n  private _constructAnalysis(\n      context: AnalysisContext, urls: ReadonlyArray<ResolvedUrl>) {\n    const getUrlResultPair:\n        (url: ResolvedUrl) => [ResolvedUrl, Document | Warning] =\n            (url) => [url, context.getDocument(url)];\n    return new Analysis(new Map(urls.map(getUrlResultPair)), context);\n  }\n\n  /**\n   * Clears all information about the given files from our caches, such that\n   * future calls to analyze() will reload these files if they're needed.\n   *\n   * The analyzer assumes that if this method isn't called with a file's url,\n   * then that file has not changed and does not need to be reloaded.\n   *\n   * @param urls The urls of files which may have changed.\n   */\n  async filesChanged(urls: string[]): Promise<void> {\n    const previousAnalysisComplete = this._analysisComplete;\n    this._analysisComplete = (async () => {\n      const previousContext = await previousAnalysisComplete;\n      return await previousContext.filesChanged(this.brandUserInputUrls(urls));\n    })();\n    await this._analysisComplete;\n  }\n\n  /**\n   * Clear all cached information from this analyzer instance.\n   *\n   * Note: if at all possible, instead tell the analyzer about the specific\n   * files that changed rather than clearing caches like this. Caching provides\n   * large performance gains.\n   */\n  async clearCaches(): Promise<void> {\n    const previousAnalysisComplete = this._analysisComplete;\n    this._analysisComplete = (async () => {\n      const previousContext = await previousAnalysisComplete;\n      return await previousContext.clearCaches();\n    })();\n    await this._analysisComplete;\n  }\n\n  /**\n   * Returns a copy of the analyzer.  If options are given, the AnalysisContext\n   * is also forked and individual properties are overridden by the options.\n   * is forked with the given options.\n   *\n   * When the analysis context is forked, its cache is preserved, so you will\n   * see a mixture of pre-fork and post-fork contents when you analyze with a\n   * forked analyzer.\n   *\n   * Note: this feature is experimental. It may be removed without being\n   *     considered a breaking change, so check for its existence before calling\n   *     it.\n   */\n  _fork(options?: ForkOptions): Analyzer {\n    const contextPromise = (async () => {\n      return options ?\n          (await this._analysisComplete)._fork(undefined, options) :\n          (await this._analysisComplete);\n    })();\n    return new Analyzer({\n      urlLoader: this._urlLoader,\n      urlResolver: this.urlResolver,\n      __contextPromise: contextPromise\n    });\n  }\n\n  /**\n   * Returns `true` if the provided resolved URL can be loaded.  Obeys the\n   * semantics defined by `UrlLoader` and should only be used to check\n   * resolved URLs.\n   */\n  canLoad(resolvedUrl: ResolvedUrl): boolean {\n    return this._urlLoader.canLoad(resolvedUrl);\n  }\n\n  /**\n   * Loads the content at the provided resolved URL.  Obeys the semantics\n   * defined by `UrlLoader` and should only be used to attempt to load resolved\n   * URLs.\n   */\n  async load(resolvedUrl: ResolvedUrl) {\n    return (await this._analysisComplete).load(resolvedUrl);\n  }\n\n  /**\n   * Resoves `url` to a new location.\n   */\n  resolveUrl(url: string): ResolvedUrl|undefined {\n    return this.urlResolver.resolve(url as PackageRelativeUrl);\n  }\n\n  // Urls from the user are assumed to be package relative\n  private brandUserInputUrls(urls: string[]): PackageRelativeUrl[] {\n    return urls as PackageRelativeUrl[];\n  }\n}\n"]}